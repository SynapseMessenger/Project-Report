\chapter{Implementación}

Para alojar el código del proyecto, se ha creado una organización en Github: SynapseMessenger; bajo la cual se han creado los repositorios pertenecientes a los distintos aspectos del proyecto: Servidor, cliente de escritorio, (cliente) aplicación móvil y documentación. \\ 

Los hitos se han definido utilizando la funcionalidad que brinda Github para ello, y las tareas, por su parte, se han definido como \hyphenquote{spanish}{issues} o incidencias, de forma que las etiquetas de las mismas han servido también para calificarlas en función de su naturaleza (bug fix, historia de usuario, mejoras, investigación, etc). \\

\section {Hito 1: Sistema de mensajería}

\subsection{Cliente}
La implementación inicial se hizo sin interfaz gráfica, a modo de prueba de la forma de uso de las librerías y experimentando con sus posibilidades. \\
El siguiente paso fue la adaptación de este código a una aplicación sobre Electron, con vistas básicas sin estilo que sirvieran como guía sobre la que desarrollar la funcionalidad. 
Posteriormente, se incluyo la librería de cifrado en el proyecto, sin intención de realizar aún trabajo en este aspecto, se trató de una prueba para comprobar la compatibilidad con la misma y anticipar futuros cambios debido a esto. \\
La prueba dio resultado, ya que fue necesaria una adaptación en la forma en la que se cargan las librerías en un navegador normal para que funcionase en una aplicación con Electron. \\ 
Afortunadamente no se trata del primer proyecto que hace frente a esta clase de problema y fue posible seguir la guía de un usuario, en la incidencia de referente al problema de compatibilidad, para cargar la librería de cifrado evitando los errores. \\ 
El problema descrito y la solución para evitarlo se pueden leer en el siguiente link:
\href{https://github.com/WhisperSystems/libsignal-protocol-javascript/issues/6}{Incidencia en el repositorio de Signal} \\

Una vez comprobado que no existe ningún problema de compatibilidad en la carga de la librería de cifrado, y que se disponía de una base sólida sobre la que implementar la funcionalidad, se ha procedido a desarrollar la estructura de acciones, reducers y llamadas a las acciones desde las vistas propias de Redux; con el fin de disponer de una estructura clara en el estado de la aplicación para los eventos de la mensajería. \\

La comunicación con el servidor se centra en el envío de mensajes con un nombre de evento descriptivo y una carga de información incluida, para manejar un constante cambio de la vista en función de la llegada y envío de mensajes/eventos se ha decidido crear un componente que englobe a aquellos componentes hijos sujetos a cambios por el chat, es decir, el componente que muestra el estado de los usuarios (Contactos) y el componente propio de la conversación (junto con sus componentes hijos: tables como la entrada de texto, etc.). Con esta solución se ha conseguido seguir la estructura propia de React, y mantener una actualización constante de la vista según sea necesario. \\

La conexión con el servidor se produce la primera vez que dicho componente padre se monta en el DOM virtual. Mientras que la escucha a los eventos que se esperan del servidor se configura una vez que el objecto de conexión (socket) se actualiza, el componente es re-renderizado, y se detecta el cambio en el estado esperado referente a la correcta conexión con el servidor. \\

Una vez conectado con el servidor y a la escucha de eventos, basta con anclar a dichos eventos las llamadas a funciones que despachen las acciones necesarias para actualizar el estado con los nuevos datos recibidos. Redux y React se encargarán de actualizar automáticamente las vistas cuando sea necesario. \\

Una vez implementada toda la funcionalidad del chat, se decoraron y adaptaron las vistas con estilos propios de Materialize (la guía de estilos de Google). \\


\subsection{Servidor}

En el ámbito del servidor, la funcionalidad esta centrada principalmente en actuar de intermediario entre el paso de eventos y mensajes entre los clientes. \\ 

Como solución para el almacenamiento de los usuarios se ha recurrido a MongoDB, mediante la popular librería Mongoose para Node.js. \\

Se ha implementado una solución para que en el caso de tener que migrar de solución de base de datos, no tocar el código referente a la lógica de negocio (chat). Se basa en una capa intermedia que actúa como \hyphenquote{spanish}{handler} de la base de datos, que consta de los métodos llamados desde la lógica para las operaciones referentes al manejo de datos persistentes. De forma que si se decidiera cambiar la capa de almacenamiento de datos por una alternativa, habría que adaptar dichos métodos y el resto del código del servidor quedaría intacto. \\ 

En este hito se implementó también una solución para almacenar mensajes pendientes (enviados a los usuarios cuando estos se encuentran desconectados), junto con la información básica del modelo de usuario, nombre y estado de la conexión. \\

En un principio, se implementó también la funcionalidad para el registro mediante contraseñas, siendo estas almacenadas cifradas en la base de datos, además del email. Para el cifrado se utilizó el paquete de Node.js llamado \hyphenquote{spanish}{bcrypt} que proporciona opciones y métodos para operaciones criptográficas. Finalmente, este enfoque de cara al registro fue sustituido por el uso únicamente del nombre de usuario, para simplificar el desarrollo. Sin embargo, en el caso de la puesta en producción de la aplicación, sería un trabajo de relativa trivialidad implementar dicha funcionalidad nuevamente. \\

\section{Hito 2: Uso del protocolo Signal}

\subsection{Cliente}

Como se ha mencionado anteriormente, la implementación del cifrado por el protocolo Signal viene dado por el uso de la librería que la organización autora del cifrado (Open Whisper Systems) ha puesto a disposición del público en sus repositorios. \\ 

Dicha implementación puede dividirse en tres partes fundamentales: 

\begin{itemize}
\item {Generación de claves privada y de identidad cuando se lanza la aplicación}
\item {Generación de claves públicas según sea necesario en cada mensaje enviado}
\item {Uso de claves públicas de contactos para descifrar mensajes}
\end{itemize}

Las claves se generan el momento en el que el usuario introduce el nombre o alias con el que desea registrarse o iniciar sesión en la aplicación. Pese a ser un proceso computacionalmente pesado, lleva alrededor de un segundo y se produce simultáneamente con la conexión al servidor. Se ha implementado de esta manera para evitar en medida de lo posible el impacto del proceso sobre la experiencia de usuario. \\

La implementación de las operaciones criptográficas de la librería utiliza el tipo de dato ArrayBuffer para el tratamiento de las claves, mientras que para el envío de las claves de un cliente a otro se han utilizado cadenas en base 64. Por lo tanto, ha sido necesaria la implementación de métodos que permitan la transformación de las claves entre ArrayBuffer, cadenas de texto y cadenas de texto en base 64. \\

Por otro lado, se han implementado métodos que encadenan las distintas operaciones necesarias para la generación de las claves públicas de cifrado y de la generación del paquete inicial de claves (clave de identidad, clave de cifrado privada). \\

Se ha extendido la funcionalidad previa al envío de mensajes para cifrarlos, y ha sido necesaria la extensión de los eventos al servidor, ya que es necesario solicitar claves de cifrado a los contactos cuando se recibe un mensaje, de forma que estos puedan ser descifrados a texto plano.

\subsection{Servidor}

En este hito el rol del servidor también es la de agente intermediario entre los contactos, con la diferencia de que ha de incluirse el manejo de eventos relativo al paso de claves entre los mismos.

\section{Hito 3: Despliegue en la red Tor}



